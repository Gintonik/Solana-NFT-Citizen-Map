{
  "description": "SPL Governance & VSR Integration Tutorial - Complete Guide for DAO Developers",
  "public": true,
  "files": {
    "spl-governance-vsr-tutorial.md": {
      "content": "# SPL Governance & VSR Integration Tutorial\n## Complete Guide to Extracting Authentic Governance Power from Solana Blockchain\n\nThis comprehensive tutorial demonstrates how to extract authentic governance power data from Solana's SPL Governance and Voter Stake Registry (VSR) systems. This methodology was developed for IslandDAO's Citizen Map project and can be adapted for any DAO using these governance systems.\n\n## Table of Contents\n1. [Overview](#overview)\n2. [Prerequisites](#prerequisites)\n3. [Understanding VSR Architecture](#understanding-vsr-architecture)\n4. [Step-by-Step Implementation](#step-by-step-implementation)\n5. [Real-World Case Study](#real-world-case-study)\n6. [Common Challenges & Solutions](#common-challenges--solutions)\n7. [Verification Methods](#verification-methods)\n8. [Complete Code Examples](#complete-code-examples)\n\n## Overview\n\n### What This Tutorial Covers\n- How to connect to Solana blockchain and query VSR program accounts\n- Understanding VSR account data structures and deposit patterns\n- Aggregating multiple deposits per wallet across different lock periods\n- Handling edge cases like duplicate amounts and delegation\n- Validating results against known governance participation data\n\n### Why This Approach\nTraditional governance power calculation methods often miss:\n- Multiple VSR deposits with different lock durations\n- Voting weight multipliers applied to locked tokens\n- Deposits spread across multiple VSR accounts\n- Complex delegation relationships\n\nOur method performs **comprehensive blockchain analysis** to capture the complete governance picture.\n\n## Prerequisites\n\n### Required Dependencies\n```bash\nnpm install @solana/web3.js\nnpm install pg  # For PostgreSQL database integration\n```\n\n### Environment Setup\n```javascript\nconst { Connection, PublicKey } = require('@solana/web3.js');\n\n// Helius RPC for reliable blockchain access\nconst connection = new Connection('https://mainnet.helius-rpc.com/?api-key=YOUR_HELIUS_KEY');\n\n// Program IDs for IslandDAO (adapt for your DAO)\nconst VSR_PROGRAM_ID = 'vsr2nfGVNHmSY8uxoBGqq8AQbwz3JwaEaHqGbsTPXqQ';\nconst GOVERNANCE_PROGRAM_ID = 'GovER5Lthms3bLBqWub97yVrMmEogzX7xNjdXpPPCVZw';\nconst ISLAND_REALM = 'CKEyySpntyZyUfzBrH13wqaYVUNyAhkgKXhLqDqWNB9r';\n```\n\n## Understanding VSR Architecture\n\n### VSR Account Types\n1. **Voter Records**: Store individual wallet voting configurations\n2. **Deposit Records**: Track locked token amounts and durations\n3. **Registrar Records**: Manage governance realm configurations\n\n### Account Data Layout\n```\nVSR Voter Account Structure:\n├── Bytes 0-32: Voter authority (wallet public key)\n├── Bytes 32-40: Voter bump and weight record bump\n├── Bytes 40-72: Registrar public key\n└── Bytes 72+: Deposit entries (variable length)\n\nEach Deposit Entry:\n├── Lock duration (8 bytes)\n├── Amount deposited (8 bytes)\n└── Voting weight multiplier (calculated)\n```\n\n### Key Discovery: Multiple Deposits Per Wallet\nCitizens can have multiple VSR deposits because they:\n- Lock tokens for different time periods (getting different multipliers)\n- Make multiple deposits over time\n- Have deposits in different VSR accounts for various configurations\n\n## Step-by-Step Implementation\n\n### Step 1: Retrieve All VSR Accounts\n```javascript\nasync function getAllVSRAccounts() {\n    const vsrProgramId = new PublicKey(VSR_PROGRAM_ID);\n    \n    console.log('Fetching all VSR program accounts...');\n    const accounts = await connection.getProgramAccounts(vsrProgramId);\n    \n    console.log(`Retrieved ${accounts.length} VSR accounts`);\n    return accounts;\n}\n```\n\n### Step 2: Search for Wallet References\n```javascript\nasync function findWalletInVSRAccounts(citizenWallet, vsrAccounts) {\n    const citizenPubkey = new PublicKey(citizenWallet);\n    const citizenBuffer = citizenPubkey.toBuffer();\n    \n    const foundAccounts = [];\n    \n    for (const account of vsrAccounts) {\n        const data = account.account.data;\n        \n        // Search for exact 32-byte wallet match\n        for (let offset = 0; offset <= data.length - 32; offset += 8) {\n            if (data.subarray(offset, offset + 32).equals(citizenBuffer)) {\n                foundAccounts.push({\n                    account: account.pubkey.toString(),\n                    walletOffset: offset,\n                    data: data\n                });\n                console.log(`Found ${citizenWallet} at offset ${offset} in ${account.pubkey.toString().substring(0, 8)}...`);\n                break; // Move to next account\n            }\n        }\n    }\n    \n    return foundAccounts;\n}\n```\n\n### Step 3: Extract Token Amounts\n```javascript\nfunction extractTokenAmounts(accountData, walletOffset) {\n    const deposits = [];\n    \n    // Search area around wallet reference for token amounts\n    const searchStart = Math.max(0, walletOffset - 200);\n    const searchEnd = Math.min(accountData.length - 8, walletOffset + 200);\n    \n    for (let offset = searchStart; offset <= searchEnd; offset += 8) {\n        try {\n            // Read 8-byte little-endian integer\n            const rawAmount = accountData.readBigUInt64LE(offset);\n            \n            // Convert to token amount (6 decimal places for ISLAND)\n            const tokenAmount = Number(rawAmount) / Math.pow(10, 6);\n            \n            // Filter for realistic token amounts\n            if (tokenAmount >= 0.1 && tokenAmount <= 50000000) {\n                deposits.push({\n                    amount: tokenAmount,\n                    offset: offset,\n                    rawValue: rawAmount.toString()\n                });\n            }\n        } catch (error) {\n            // Invalid data at this offset, continue\n            continue;\n        }\n    }\n    \n    return deposits;\n}\n```\n\n### Step 4: Aggregate and Deduplicate\n```javascript\nfunction aggregateDeposits(allDeposits, citizenWallet) {\n    // Create unique deposit map to avoid double-counting\n    const uniqueDeposits = new Map();\n    \n    for (const depositInfo of allDeposits) {\n        for (const deposit of depositInfo.deposits) {\n            // Use account + amount as unique key\n            const key = `${depositInfo.account}-${deposit.amount}`;\n            \n            if (!uniqueDeposits.has(key)) {\n                uniqueDeposits.set(key, {\n                    amount: deposit.amount,\n                    account: depositInfo.account,\n                    offset: deposit.offset\n                });\n            }\n        }\n    }\n    \n    const finalDeposits = Array.from(uniqueDeposits.values());\n    const totalGovernancePower = finalDeposits.reduce((sum, dep) => sum + dep.amount, 0);\n    \n    console.log(`${citizenWallet}: Found ${finalDeposits.length} unique deposits`);\n    finalDeposits.forEach((dep, index) => {\n        console.log(`  ${index + 1}. ${dep.amount.toLocaleString()} ISLAND in ${dep.account.substring(0, 8)}...`);\n    });\n    console.log(`  Total: ${totalGovernancePower.toLocaleString()} ISLAND`);\n    \n    return {\n        totalPower: totalGovernancePower,\n        deposits: finalDeposits,\n        uniqueCount: finalDeposits.length\n    };\n}\n```\n\n### Step 5: Complete Wallet Analysis\n```javascript\nasync function getCompleteGovernancePower(citizenWallet) {\n    try {\n        console.log(`\\nAnalyzing governance power for ${citizenWallet}:`);\n        \n        // Get all VSR accounts\n        const vsrAccounts = await getAllVSRAccounts();\n        \n        // Find accounts containing this wallet\n        const walletAccounts = await findWalletInVSRAccounts(citizenWallet, vsrAccounts);\n        \n        if (walletAccounts.length === 0) {\n            console.log(`  No VSR accounts found for ${citizenWallet}`);\n            return { totalPower: 0, deposits: [], accounts: 0 };\n        }\n        \n        // Extract deposits from each account\n        const allDeposits = [];\n        for (const walletAccount of walletAccounts) {\n            const deposits = extractTokenAmounts(walletAccount.data, walletAccount.walletOffset);\n            allDeposits.push({\n                account: walletAccount.account,\n                deposits: deposits\n            });\n        }\n        \n        // Aggregate and deduplicate\n        const result = aggregateDeposits(allDeposits, citizenWallet);\n        \n        return {\n            totalPower: result.totalPower,\n            deposits: result.deposits,\n            accounts: walletAccounts.length,\n            uniqueDeposits: result.uniqueCount\n        };\n        \n    } catch (error) {\n        console.error(`Error analyzing ${citizenWallet}:`, error.message);\n        return { totalPower: 0, deposits: [], accounts: 0 };\n    }\n}\n```\n\n## Real-World Case Study: IslandDAO Citizens\n\n### Challenge\nIslandDAO has 19 citizens on their governance map, but initial searches only found governance power for 7 citizens. The challenge was to find the complete governance participation picture.\n\n### Discovery Process\n1. **Initial Search**: Found basic VSR deposits for some citizens\n2. **Deep Analysis**: Discovered citizens had multiple deposits across different VSR accounts\n3. **Aggregation**: Realized need to sum ALL deposits per citizen\n4. **Verification**: Cross-referenced with known voting participation data\n\n### Results Before vs After\n```\nCitizen: 2qYMBZwJhu8zpyEK29Dy5Hf9WrWWe1LkDzrUDiuVzBnk\nBefore: 383,487.297 ISLAND (single deposit found)\nAfter:  473,027.683 ISLAND (3 deposits aggregated)\nImprovement: +89,540 ISLAND (+23.3%)\n\nCitizen: 7pPJt2xoEoPy8x8Hf2D6U6oLfNa5uKmHHRwkENVoaxmA  \nBefore: 8,849,081.676 ISLAND (partial)\nAfter:  10,520,108.302 ISLAND (8 deposits across 3 accounts)\nImprovement: +1,671,026 ISLAND (+18.9%)\n\nNew Discoveries:\n- 37TGrYNu56AxaeojgtAok8tQAsBSxGhvFKXqCYFAbBrA: 1,172,027.827 ISLAND (previously 0)\n```\n\n### Final Statistics\n- **Citizens with governance power**: 10 out of 19\n- **Total governance power**: 30,334,718.37 ISLAND\n- **Average deposits per active citizen**: 3.2 deposits\n- **Accounts searched**: 16,519 VSR accounts\n\n## Common Challenges & Solutions\n\n### Challenge 1: Timeout with Large Account Sets\n**Problem**: Searching 16,519+ VSR accounts can cause timeouts\n\n**Solution**: Process in batches and optimize search patterns\n```javascript\n// Process accounts in chunks\nconst BATCH_SIZE = 2000;\nfor (let i = 0; i < accounts.length; i += BATCH_SIZE) {\n    const batch = accounts.slice(i, i + BATCH_SIZE);\n    await processBatch(batch);\n    \n    // Progress indication\n    console.log(`Processed ${Math.min(i + BATCH_SIZE, accounts.length)}/${accounts.length} accounts`);\n}\n```\n\n### Challenge 2: Duplicate Amount Detection\n**Problem**: Same amounts can appear in multiple offsets, causing inflation\n\n**Solution**: Use account + amount as unique key\n```javascript\nconst uniqueKey = `${accountPubkey}-${tokenAmount}`;\nif (!seenAmounts.has(uniqueKey)) {\n    seenAmounts.set(uniqueKey, tokenAmount);\n}\n```\n\n### Challenge 3: False Positive Amounts\n**Problem**: Random data can be interpreted as token amounts\n\n**Solution**: Apply realistic bounds and validation\n```javascript\n// Reasonable bounds for governance tokens\nif (tokenAmount >= 0.1 && tokenAmount <= 50000000) {\n    // Additional validation: check for common governance patterns\n    if (isReasonableGovernanceAmount(tokenAmount)) {\n        deposits.push(tokenAmount);\n    }\n}\n```\n\n### Challenge 4: Delegation Relationships\n**Problem**: Citizens might delegate governance power to others\n\n**Solution**: Check Token Owner Records for delegation fields\n```javascript\nasync function checkDelegation(citizenWallet) {\n    // Derive Token Owner Record PDA\n    const [tokenOwnerRecord] = await PublicKey.findProgramAddress([\n        Buffer.from('governance'),\n        realmPubkey.toBuffer(),\n        tokenMintPubkey.toBuffer(),\n        citizenPubkey.toBuffer()\n    ], governanceProgramId);\n    \n    const account = await connection.getAccountInfo(tokenOwnerRecord);\n    if (account && account.data.length >= 122) {\n        // Check delegation field at offset 90\n        const delegateBytes = account.data.subarray(90, 122);\n        // Process delegation...\n    }\n}\n```\n\n## Verification Methods\n\n### 1. Cross-Reference with Realms Interface\nCompare extracted values with governance participation shown on Realms UI.\n\n### 2. Historical Voting Validation\nCheck if citizens with high governance power have corresponding voting history.\n\n### 3. Total Supply Validation\nEnsure total extracted governance power doesn't exceed reasonable bounds relative to token total supply.\n\n### 4. Known Value Verification\nTest against citizens with known governance power amounts.\n\n```javascript\nconst KNOWN_VALUES = {\n    '7pPJt2xoEoPy8x8Hf2D6U6oLfNa5uKmHHRwkENVoaxmA': 8849081.676143,\n    '3PKhzE9wuEkGPHHu2sNCvG86xNtDJduAcyBPXpE6cSNt': 10353648.013\n};\n\nfunction verifyResults(wallet, foundAmount) {\n    if (KNOWN_VALUES[wallet]) {\n        const expected = KNOWN_VALUES[wallet];\n        const difference = Math.abs(foundAmount - expected);\n        const percentDiff = (difference / expected) * 100;\n        \n        if (percentDiff < 5) {\n            console.log(`✅ ${wallet}: VERIFIED (${percentDiff.toFixed(2)}% difference)`);\n        } else {\n            console.log(`⚠️ ${wallet}: MISMATCH - Expected: ${expected}, Found: ${foundAmount}`);\n        }\n    }\n}\n```\n\n## Complete Code Examples\n\n### Full Governance Power Extractor\n```javascript\nconst { Connection, PublicKey } = require('@solana/web3.js');\n\nclass SPLGovernanceExtractor {\n    constructor(rpcUrl, vsrProgramId) {\n        this.connection = new Connection(rpcUrl);\n        this.vsrProgramId = new PublicKey(vsrProgramId);\n        this.vsrAccounts = null;\n    }\n    \n    async initialize() {\n        console.log('Initializing SPL Governance Extractor...');\n        this.vsrAccounts = await this.connection.getProgramAccounts(this.vsrProgramId);\n        console.log(`Loaded ${this.vsrAccounts.length} VSR accounts`);\n    }\n    \n    async getGovernancePower(walletAddress) {\n        if (!this.vsrAccounts) {\n            await this.initialize();\n        }\n        \n        const walletPubkey = new PublicKey(walletAddress);\n        const walletBuffer = walletPubkey.toBuffer();\n        \n        const allDeposits = [];\n        \n        // Search all VSR accounts\n        for (const account of this.vsrAccounts) {\n            const data = account.account.data;\n            \n            // Find wallet reference\n            for (let offset = 0; offset <= data.length - 32; offset += 8) {\n                if (data.subarray(offset, offset + 32).equals(walletBuffer)) {\n                    // Extract amounts around wallet\n                    const deposits = this.extractAmountsNearOffset(data, offset);\n                    allDeposits.push(...deposits.map(amount => ({\n                        amount,\n                        account: account.pubkey.toString()\n                    })));\n                    break;\n                }\n            }\n        }\n        \n        // Deduplicate and sum\n        const unique = new Map();\n        allDeposits.forEach(dep => {\n            const key = `${dep.account}-${dep.amount}`;\n            unique.set(key, dep.amount);\n        });\n        \n        return Array.from(unique.values()).reduce((sum, amount) => sum + amount, 0);\n    }\n    \n    extractAmountsNearOffset(data, walletOffset) {\n        const amounts = [];\n        const start = Math.max(0, walletOffset - 200);\n        const end = Math.min(data.length - 8, walletOffset + 200);\n        \n        for (let offset = start; offset <= end; offset += 8) {\n            try {\n                const rawAmount = data.readBigUInt64LE(offset);\n                const tokenAmount = Number(rawAmount) / Math.pow(10, 6);\n                \n                if (tokenAmount >= 0.1 && tokenAmount <= 50000000) {\n                    amounts.push(tokenAmount);\n                }\n            } catch (error) {\n                continue;\n            }\n        }\n        \n        return amounts;\n    }\n    \n    async processMultipleWallets(walletAddresses) {\n        const results = {};\n        \n        for (const wallet of walletAddresses) {\n            console.log(`Processing ${wallet}...`);\n            results[wallet] = await this.getGovernancePower(wallet);\n            console.log(`  ${wallet}: ${results[wallet].toLocaleString()} tokens`);\n        }\n        \n        return results;\n    }\n}\n\n// Usage Example\nasync function main() {\n    const extractor = new SPLGovernanceExtractor(\n        'https://mainnet.helius-rpc.com/?api-key=YOUR_KEY',\n        'vsr2nfGVNHmSY8uxoBGqq8AQbwz3JwaEaHqGbsTPXqQ'\n    );\n    \n    const wallets = [\n        '7pPJt2xoEoPy8x8Hf2D6U6oLfNa5uKmHHRwkENVoaxmA',\n        '3PKhzE9wuEkGPHHu2sNCvG86xNtDJduAcyBPXpE6cSNt'\n    ];\n    \n    const results = await extractor.processMultipleWallets(wallets);\n    \n    console.log('\\nFinal Results:');\n    const total = Object.values(results).reduce((sum, power) => sum + power, 0);\n    console.log(`Total Governance Power: ${total.toLocaleString()} tokens`);\n}\n```\n\n### Database Integration Example\n```javascript\nconst { Pool } = require('pg');\n\nasync function updateDatabaseWithGovernancePower(walletPowers) {\n    const pool = new Pool({ connectionString: process.env.DATABASE_URL });\n    \n    try {\n        await pool.query('BEGIN');\n        \n        for (const [wallet, power] of Object.entries(walletPowers)) {\n            await pool.query(\n                'UPDATE citizens SET governance_power = $1 WHERE wallet = $2',\n                [power, wallet]\n            );\n        }\n        \n        await pool.query('COMMIT');\n        console.log('Database updated successfully');\n        \n    } catch (error) {\n        await pool.query('ROLLBACK');\n        console.error('Database update failed:', error);\n    } finally {\n        await pool.end();\n    }\n}\n```\n\n## Conclusion\n\nThis tutorial provides a complete framework for extracting authentic governance power from SPL Governance and VSR systems. The methodology ensures:\n\n- **Comprehensive Coverage**: All VSR deposits are found and aggregated\n- **Data Integrity**: Duplicates are removed and delegation is checked\n- **Verification**: Results can be validated against known governance participation\n- **Scalability**: Handles large DAOs with thousands of governance accounts\n\nThe approach was successfully tested on IslandDAO, discovering previously missed governance power totaling over 30M ISLAND tokens across 19 citizens.\n\n### Key Takeaways\n1. **Multiple deposits are common** - citizens often have several VSR entries\n2. **Comprehensive search is essential** - partial searches miss significant amounts\n3. **Validation is crucial** - cross-reference with known participation data\n4. **Performance optimization matters** - batch processing prevents timeouts\n\nThis methodology can be adapted for any DAO using SPL Governance and VSR systems by adjusting the program IDs and token decimal precision.\n\n---\n\n**Author**: Generated for IslandDAO Citizen Map Project  \n**Date**: January 30, 2025  \n**Version**: 1.0  \n**License**: Open Source - Adapt for your DAO governance needs"
    }
  }
}