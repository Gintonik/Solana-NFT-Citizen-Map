<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Globe Labels</title>
  <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    
    #container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .city-label {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      border: 1px solid rgba(255, 255, 255, 0.5);
      white-space: nowrap;
      z-index: 100;
      transition: opacity 0.3s ease, font-size 0.3s ease;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }
    
    .city-label.tier-1 {
      font-size: 14px;
      font-weight: bold;
      background-color: rgba(0, 0, 0, 0.8);
      border-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }
    
    .city-label.tier-2 {
      font-size: 13px;
      font-weight: bold;
      background-color: rgba(0, 0, 0, 0.75);
    }
    
    .city-label.tier-3 {
      font-size: 12px;
      background-color: rgba(0, 0, 0, 0.7);
    }
    
    .city-label.tier-4 {
      font-size: 11px;
      background-color: rgba(0, 0, 0, 0.65);
    }
    
    .controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
    }
    
    .controls button {
      background: #333;
      color: white;
      border: none;
      padding: 8px 12px;
      margin: 4px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .controls button:hover {
      background: #444;
    }
    
    #stats {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      color: #0f0;
      border-radius: 4px;
      font-family: monospace;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="stats">FPS: 0 | Visible Labels: 0</div>
    <div class="controls">
      <button id="zoomIn">Zoom In</button>
      <button id="zoomOut">Zoom Out</button>
      <button id="toggleRotation">Pause Rotation</button>
      <button id="toggleLabels">Hide Labels</button>
    </div>
  </div>
  
  <script>
    // App state
    let isRotating = true;
    let showLabels = true;
    let targetZoomLevel = 0.5; // Initial zoom level (0-1)
    let currentZoomLevel = 0.5;
    let lastFrameTime = 0;
    let frameCount = 0;
    let fps = 0;
    let visibleLabelCount = 0;
    
    // Three.js objects
    let scene, camera, renderer, controls;
    let earth, atmosphere, bordersMesh;
    
    // City data with tiers for zoom-based visibility
    const cities = [
      // Tier 1 - Major cities - Always visible
      { name: "New York", lat: 40.7128, lng: -74.0060, tier: 1 },
      { name: "Tokyo", lat: 35.6762, lng: 139.6503, tier: 1 },
      { name: "London", lat: 51.5074, lng: -0.1278, tier: 1 },
      { name: "Beijing", lat: 39.9042, lng: 116.4074, tier: 1 },
      { name: "Shanghai", lat: 31.2304, lng: 121.4737, tier: 1 },
      { name: "Delhi", lat: 28.7041, lng: 77.1025, tier: 1 },
      { name: "Mexico City", lat: 19.4326, lng: -99.1332, tier: 1 },
      { name: "SÃ£o Paulo", lat: -23.5505, lng: -46.6333, tier: 1 },
      
      // Tier 2 - Large cities - Visible at medium zoom
      { name: "Paris", lat: 48.8566, lng: 2.3522, tier: 2 },
      { name: "Los Angeles", lat: 34.0522, lng: -118.2437, tier: 2 },
      { name: "Moscow", lat: 55.7558, lng: 37.6173, tier: 2 },
      { name: "Sydney", lat: -33.8688, lng: 151.2093, tier: 2 },
      { name: "Rio de Janeiro", lat: -22.9068, lng: -43.1729, tier: 2 },
      { name: "Cairo", lat: 30.0444, lng: 31.2357, tier: 2 },
      { name: "Singapore", lat: 1.3521, lng: 103.8198, tier: 2 },
      { name: "Hong Kong", lat: 22.3193, lng: 114.1694, tier: 2 },
      { name: "Istanbul", lat: 41.0082, lng: 28.9784, tier: 2 },
      { name: "Seoul", lat: 37.5665, lng: 126.9780, tier: 2 },
      
      // Tier 3 - Medium cities - Visible at close zoom
      { name: "Madrid", lat: 40.4168, lng: -3.7038, tier: 3 },
      { name: "Rome", lat: 41.9028, lng: 12.4964, tier: 3 },
      { name: "Berlin", lat: 52.5200, lng: 13.4050, tier: 3 },
      { name: "Chicago", lat: 41.8781, lng: -87.6298, tier: 3 },
      { name: "Toronto", lat: 43.6532, lng: -79.3832, tier: 3 },
      { name: "Dubai", lat: 25.2048, lng: 55.2708, tier: 3 },
      { name: "San Francisco", lat: 37.7749, lng: -122.4194, tier: 3 },
      { name: "Bangkok", lat: 13.7563, lng: 100.5018, tier: 3 },
      { name: "Mumbai", lat: 19.0760, lng: 72.8777, tier: 3 },
      { name: "Jakarta", lat: -6.2088, lng: 106.8456, tier: 3 },
      
      // Tier 4 - Small cities - Visible only at very close zoom
      { name: "Amsterdam", lat: 52.3676, lng: 4.9041, tier: 4 },
      { name: "Las Vegas", lat: 36.1699, lng: -115.1398, tier: 4 },
      { name: "Miami", lat: 25.7617, lng: -80.1918, tier: 4 },
      { name: "Lisbon", lat: 38.7223, lng: -9.1393, tier: 4 },
      { name: "Athens", lat: 37.9838, lng: 23.7275, tier: 4 },
      { name: "Prague", lat: 50.0755, lng: 14.4378, tier: 4 },
      { name: "Vancouver", lat: 49.2827, lng: -123.1207, tier: 4 },
      { name: "Seattle", lat: 47.6062, lng: -122.3321, tier: 4 },
      { name: "Dublin", lat: 53.3498, lng: -6.2603, tier: 4 },
      { name: "Vienna", lat: 48.2082, lng: 16.3738, tier: 4 },
      { name: "Boston", lat: 42.3601, lng: -71.0589, tier: 4 },
      { name: "Barcelona", lat: 41.3851, lng: 2.1734, tier: 4 },
      { name: "Melbourne", lat: -37.8136, lng: 144.9631, tier: 4 },
      { name: "Kyoto", lat: 35.0116, lng: 135.7681, tier: 4 },
      { name: "Edinburgh", lat: 55.9533, lng: -3.1883, tier: 4 }
    ];
    
    // City label elements
    const cityLabels = [];
    
    // Initialize the application
    init();
    animate();
    
    function init() {
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 300;
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('container').appendChild(renderer.domElement);
      
      // Create controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.5;
      controls.minDistance = 150;
      controls.maxDistance = 400;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.15; // Slowed down rotation
      
      // Create Earth
      createEarth();
      
      // Create atmosphere
      createAtmosphere();
      
      // Load country borders
      loadCountryBorders();
      
      // Create city labels
      createCityLabels();
      
      // Set up event listeners
      setupEventListeners();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }
    
    function createEarth() {
      // Create Earth geometry
      const earthGeometry = new THREE.SphereGeometry(100, 64, 64);
      
      // Load Earth texture
      const textureLoader = new THREE.TextureLoader();
      const earthTexture = textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_8k.jpg');
      const bumpMap = textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/elev_bump_8k.jpg');
      const specularMap = textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/water_8k.png');
      
      // Create Earth material
      const earthMaterial = new THREE.MeshPhongMaterial({
        map: earthTexture,
        bumpMap: bumpMap,
        bumpScale: 0.5,
        specularMap: specularMap,
        specular: new THREE.Color('grey'),
        shininess: 5
      });
      
      // Create Earth mesh
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x333333);
      scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
    }
    
    function createAtmosphere() {
      // Create atmosphere geometry
      const atmosphereGeometry = new THREE.SphereGeometry(102, 64, 64);
      
      // Create atmosphere material
      const atmosphereMaterial = new THREE.MeshPhongMaterial({
        color: 0x4ca6ff,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide
      });
      
      // Create atmosphere mesh
      atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
      scene.add(atmosphere);
    }
    
    function loadCountryBorders() {
      fetch('https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_admin_0_countries.geojson')
        .then(response => response.json())
        .then(data => {
          createBordersMesh(data);
        })
        .catch(error => {
          console.error('Error loading country borders:', error);
        });
    }
    
    function createBordersMesh(geoJson) {
      if (bordersMesh) {
        scene.remove(bordersMesh);
      }
      
      // Create material for borders
      const bordersMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.3,
        linewidth: 1
      });
      
      // Create geometry for borders
      const bordersGeometry = new THREE.BufferGeometry();
      const vertices = [];
      
      // Process GeoJSON features
      geoJson.features.forEach(feature => {
        if (feature.geometry.type === 'Polygon') {
          processBordersPolygon(feature.geometry.coordinates, vertices);
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach(polygon => {
            processBordersPolygon(polygon, vertices);
          });
        }
      });
      
      // Set vertices
      bordersGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      
      // Create borders mesh
      bordersMesh = new THREE.LineSegments(bordersGeometry, bordersMaterial);
      scene.add(bordersMesh);
    }
    
    function processBordersPolygon(polygon, vertices) {
      polygon.forEach(ring => {
        for (let i = 0; i < ring.length - 1; i++) {
          const point1 = latLngToVector3(ring[i][1], ring[i][0], 101);
          const point2 = latLngToVector3(ring[i + 1][1], ring[i + 1][0], 101);
          
          vertices.push(point1.x, point1.y, point1.z);
          vertices.push(point2.x, point2.y, point2.z);
        }
      });
    }
    
    function createCityLabels() {
      // Create container for labels
      const labelContainer = document.getElementById('container');
      
      // Create label elements for each city
      cities.forEach(city => {
        const label = document.createElement('div');
        label.className = `city-label tier-${city.tier}`;
        label.textContent = city.name;
        label.style.display = 'none'; // Hidden initially
        labelContainer.appendChild(label);
        
        // Store city information
        cityLabels.push({
          element: label,
          position: latLngToVector3(city.lat, city.lng, 100),
          city: city
        });
      });
    }
    
    function updateCityLabels() {
      if (!showLabels) {
        // Hide all labels if labels are toggled off
        cityLabels.forEach(item => {
          item.element.style.display = 'none';
        });
        visibleLabelCount = 0;
        return;
      }
      
      // Calculate current zoom factor (0-1)
      const cameraDistance = camera.position.length();
      const zoomFactor = Math.max(0, Math.min(1, 
        (controls.maxDistance - cameraDistance) / (controls.maxDistance - controls.minDistance)
      ));
      
      // Track visible labels for performance monitoring
      visibleLabelCount = 0;
      
      // Track occupied positions to prevent overlaps
      const occupiedPositions = [];
      
      // Process labels in order of importance (tier)
      [...cityLabels]
        .sort((a, b) => a.city.tier - b.city.tier)
        .forEach(item => {
          // Determine if label should be shown based on zoom level
          const shouldShow = (
            item.city.tier === 1 || // Tier 1 - always visible
            (item.city.tier === 2 && zoomFactor > 0.3) || // Tier 2 - medium zoom
            (item.city.tier === 3 && zoomFactor > 0.6) || // Tier 3 - close zoom
            (item.city.tier === 4 && zoomFactor > 0.85)   // Tier 4 - very close zoom
          );
          
          if (!shouldShow) {
            item.element.style.display = 'none';
            return;
          }
          
          // Get position in world space
          const worldPosition = item.position.clone().applyMatrix4(earth.matrixWorld);
          
          // Project to screen space
          const vector = worldPosition.clone().project(camera);
          
          // Convert to screen coordinates
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
          
          // Check if city is behind the globe (not visible)
          if (vector.z > 0.1) {
            item.element.style.display = 'none';
            return;
          }
          
          // Apply adaptive sizing based on zoom and importance
          const baseFontSize = 9 + (4 - item.city.tier) * 1.2;
          const fontSize = Math.max(9, Math.min(16, baseFontSize * (1 + zoomFactor * 0.5)));
          item.element.style.fontSize = `${fontSize}px`;
          
          // Calculate label dimensions for overlap detection
          const labelWidth = item.city.name.length * fontSize * 0.6;
          const labelHeight = fontSize * 2;
          
          // Find non-overlapping position
          let finalPosition = {
            x: x,
            y: y
          };
          
          // Check for overlaps
          let hasOverlap = false;
          for (const occupied of occupiedPositions) {
            if (Math.abs(finalPosition.x - occupied.x) < (labelWidth + occupied.width) / 2 &&
                Math.abs(finalPosition.y - occupied.y) < (labelHeight + occupied.height) / 2) {
              hasOverlap = true;
              break;
            }
          }
          
          // If overlap, find better position
          if (hasOverlap) {
            // Move label away from center
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const dirX = x - centerX;
            const dirY = y - centerY;
            const length = Math.sqrt(dirX * dirX + dirY * dirY);
            
            if (length > 0) {
              // Normalize direction
              const normX = dirX / length;
              const normY = dirY / length;
              
              // Move in that direction
              finalPosition.x = x + normX * labelWidth;
              finalPosition.y = y + normY * labelHeight;
            }
          }
          
          // Position the label
          item.element.style.left = finalPosition.x + 'px';
          item.element.style.top = finalPosition.y + 'px';
          
          // Calculate distance from viewport center for fading
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          const distX = finalPosition.x - centerX;
          const distY = finalPosition.y - centerY;
          const distance = Math.sqrt(distX * distX + distY * distY);
          const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
          const normalizedDist = Math.min(1, distance / (maxDist * 0.7));
          
          // Apply fade to labels near edge
          const opacity = 1 - Math.pow(normalizedDist, 2);
          item.element.style.opacity = opacity;
          
          // Show label
          item.element.style.display = 'block';
          
          // Add to occupied positions
          occupiedPositions.push({
            x: finalPosition.x,
            y: finalPosition.y,
            width: labelWidth,
            height: labelHeight
          });
          
          // Increment visible count
          visibleLabelCount++;
        });
    }
    
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      
      return new THREE.Vector3(x, y, z);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate(time) {
      requestAnimationFrame(animate);
      
      // Calculate FPS
      frameCount++;
      if (time - lastFrameTime > 1000) {
        fps = Math.round(frameCount * 1000 / (time - lastFrameTime));
        frameCount = 0;
        lastFrameTime = time;
        
        // Update stats display
        document.getElementById('stats').textContent = `FPS: ${fps} | Visible Labels: ${visibleLabelCount}`;
      }
      
      // Update controls
      controls.update();
      
      // Rotate Earth if enabled
      if (isRotating) {
        earth.rotation.y += 0.0005; // Even slower rotation
        if (atmosphere) atmosphere.rotation.y += 0.0005;
        if (bordersMesh) bordersMesh.rotation.y += 0.0005;
      }
      
      // Smooth zoom interpolation
      if (Math.abs(currentZoomLevel - targetZoomLevel) > 0.01) {
        currentZoomLevel += (targetZoomLevel - currentZoomLevel) * 0.1;
        
        // Apply zoom to camera
        const direction = camera.position.clone().normalize();
        const distance = controls.minDistance + (1 - currentZoomLevel) * (controls.maxDistance - controls.minDistance);
        camera.position.copy(direction.multiplyScalar(distance));
      }
      
      // Update city labels - force update on every frame
      updateCityLabels();
      
      // Render scene
      renderer.render(scene, camera);
    }
    
    function setupEventListeners() {
      // Zoom in button
      document.getElementById('zoomIn').addEventListener('click', () => {
        zoomIn();
      });
      
      // Zoom out button
      document.getElementById('zoomOut').addEventListener('click', () => {
        zoomOut();
      });
      
      // Toggle rotation button
      document.getElementById('toggleRotation').addEventListener('click', () => {
        isRotating = !isRotating;
        controls.autoRotate = isRotating;
        document.getElementById('toggleRotation').textContent = isRotating ? 'Pause Rotation' : 'Resume Rotation';
      });
      
      // Toggle labels button
      document.getElementById('toggleLabels').addEventListener('click', () => {
        showLabels = !showLabels;
        document.getElementById('toggleLabels').textContent = showLabels ? 'Hide Labels' : 'Show Labels';
      });
    }
    
    function zoomIn() {
      // Set target zoom level (0-1 range)
      targetZoomLevel = Math.min(1, targetZoomLevel + 0.2);
      
      // Get current camera position
      const startPos = camera.position.clone();
      const direction = startPos.clone().normalize();
      const currentDist = startPos.length();
      const newDist = Math.max(currentDist * 0.8, controls.minDistance);
      const endPos = direction.multiplyScalar(newDist);
      
      // Animate zoom with easing
      const startTime = Date.now();
      const duration = 800; // 800ms for smooth transition
      
      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Cubic ease-out for smooth deceleration
        const eased = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        camera.position.lerpVectors(startPos, endPos, eased);
        controls.update();
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        }
      }
      
      animateZoom();
    }
    
    function zoomOut() {
      // Set target zoom level (0-1 range)
      targetZoomLevel = Math.max(0, targetZoomLevel - 0.2);
      
      // Get current camera position
      const startPos = camera.position.clone();
      const direction = startPos.clone().normalize();
      const currentDist = startPos.length();
      const newDist = Math.min(currentDist * 1.2, controls.maxDistance);
      const endPos = direction.multiplyScalar(newDist);
      
      // Animate zoom with easing
      const startTime = Date.now();
      const duration = 800; // 800ms for smooth transition
      
      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Cubic ease-out for smooth deceleration
        const eased = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        camera.position.lerpVectors(startPos, endPos, eased);
        controls.update();
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        }
      }
      
      animateZoom();
    }
  </script>
</body>
</html>