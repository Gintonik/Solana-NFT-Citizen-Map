<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PERKS Citizen Globe</title>
  
  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
  
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    
    #container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    
    .header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 10;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #9945FF;
    }
    
    .title {
      font-size: 24px;
      font-weight: bold;
      color: #9945FF;
    }
    
    .controls {
      display: flex;
      gap: 10px;
    }
    
    .btn {
      background-color: #9945FF;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: bold;
      transition: background-color 0.2s;
    }
    
    .btn:hover {
      background-color: #8134E0;
    }
    
    .controls-panel {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 12px;
      border-radius: 6px;
      z-index: 10;
      border: 1px solid #333;
    }
    
    .control-item {
      margin-bottom: 10px;
    }
    
    .btn.secondary {
      background-color: #333;
    }
    
    .btn.secondary:hover {
      background-color: #444;
    }
    
    .city-label {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 3px 6px;
      border-radius: 3px;
      font-size: 11px;
      pointer-events: none;
      border: 1px solid rgba(255, 255, 255, 0.3);
      white-space: nowrap;
      z-index: 5;
      transform: translate(-50%, -50%);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
      transition: opacity 0.3s ease, font-size 0.3s ease;
    }
    
    .city-label.tier-1 {
      font-size: 13px;
      font-weight: bold;
      background-color: rgba(0, 0, 0, 0.7);
    }
    
    .city-label.tier-2 {
      font-size: 12px;
      background-color: rgba(0, 0, 0, 0.65);
    }
    
    .city-label.tier-3 {
      font-size: 11px;
      background-color: rgba(0, 0, 0, 0.6);
    }
    
    .city-label.tier-4 {
      font-size: 10px;
      background-color: rgba(0, 0, 0, 0.55);
    }
    
    #performance-stats {
      position: absolute;
      top: 10px;
      left: 10px;
      background-color: rgba(0, 0, 0, 0.6);
      color: #0f0;
      padding: 5px 8px;
      border-radius: 3px;
      font-size: 12px;
      font-family: monospace;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="performance-stats">FPS: 0 | Labels: 0</div>
    
    <div class="header">
      <div class="title">PERKS Citizen Globe</div>
    </div>
    
    <div class="controls-panel">
      <div class="control-item">
        <button id="toggle-rotation" class="btn secondary">Pause Rotation</button>
      </div>
      <div class="control-item">
        <button id="toggle-borders" class="btn secondary">Hide Borders</button>
      </div>
      <div class="control-item">
        <button id="toggle-labels" class="btn secondary">Hide Labels</button>
      </div>
      <div class="control-item">
        <button id="zoom-in" class="btn secondary">Zoom In</button>
      </div>
      <div class="control-item">
        <button id="zoom-out" class="btn secondary">Zoom Out</button>
      </div>
    </div>
  </div>
  
  <script>
    // App state
    let isRotating = true;
    let showBorders = true;
    let showLabels = true;
    let lastFrameTime = 0;
    let frameCount = 0;
    let fps = 0;
    let visibleLabelCount = 0;
    let zoomLevel = 1;
    let targetZoomLevel = 1;
    let lastLabelUpdateTime = 0;
    
    // Three.js variables
    let scene, camera, renderer, controls;
    let earth, atmosphere, bordersMesh;
    let labelContainer;
    
    // Cities with tiers for zoom-based visibility
    const cities = [
      // Tier 1 - Major Cities - Always visible
      { name: 'New York', lat: 40.7128, lng: -74.0060, tier: 1 },
      { name: 'Tokyo', lat: 35.6762, lng: 139.6503, tier: 1 },
      { name: 'London', lat: 51.5074, lng: -0.1278, tier: 1 },
      { name: 'Beijing', lat: 39.9042, lng: 116.4074, tier: 1 },
      { name: 'Shanghai', lat: 31.2304, lng: 121.4737, tier: 1 },
      { name: 'Mumbai', lat: 19.0760, lng: 72.8777, tier: 1 },
      { name: 'Mexico City', lat: 19.4326, lng: -99.1332, tier: 1 },
      { name: 'Delhi', lat: 28.7041, lng: 77.1025, tier: 1 },
      
      // Tier 2 - Large Cities - Visible at medium zoom
      { name: 'Paris', lat: 48.8566, lng: 2.3522, tier: 2 },
      { name: 'Los Angeles', lat: 34.0522, lng: -118.2437, tier: 2 },
      { name: 'Moscow', lat: 55.7558, lng: 37.6173, tier: 2 },
      { name: 'Sydney', lat: -33.8688, lng: 151.2093, tier: 2 },
      { name: 'Rio de Janeiro', lat: -22.9068, lng: -43.1729, tier: 2 },
      { name: 'Cairo', lat: 30.0444, lng: 31.2357, tier: 2 },
      { name: 'Singapore', lat: 1.3521, lng: 103.8198, tier: 2 },
      { name: 'Hong Kong', lat: 22.3193, lng: 114.1694, tier: 2 },
      
      // Tier 3 - Medium Cities - Visible at close zoom
      { name: 'Madrid', lat: 40.4168, lng: -3.7038, tier: 3 },
      { name: 'Rome', lat: 41.9028, lng: 12.4964, tier: 3 },
      { name: 'Berlin', lat: 52.5200, lng: 13.4050, tier: 3 },
      { name: 'Chicago', lat: 41.8781, lng: -87.6298, tier: 3 },
      { name: 'Toronto', lat: 43.6532, lng: -79.3832, tier: 3 },
      { name: 'Dubai', lat: 25.2048, lng: 55.2708, tier: 3 },
      { name: 'San Francisco', lat: 37.7749, lng: -122.4194, tier: 3 },
      { name: 'Bangkok', lat: 13.7563, lng: 100.5018, tier: 3 },
      
      // Tier 4 - Small Cities - Visible only at very close zoom
      { name: 'Amsterdam', lat: 52.3676, lng: 4.9041, tier: 4 },
      { name: 'Las Vegas', lat: 36.1699, lng: -115.1398, tier: 4 },
      { name: 'Miami', lat: 25.7617, lng: -80.1918, tier: 4 },
      { name: 'Lisbon', lat: 38.7223, lng: -9.1393, tier: 4 },
      { name: 'Athens', lat: 37.9838, lng: 23.7275, tier: 4 },
      { name: 'Prague', lat: 50.0755, lng: 14.4378, tier: 4 },
      { name: 'Vancouver', lat: 49.2827, lng: -123.1207, tier: 4 },
      { name: 'Seattle', lat: 47.6062, lng: -122.3321, tier: 4 }
    ];
    
    // City label objects
    let cityLabels = [];
    
    // Initialize globe
    init();
    animate();
    
    function init() {
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 300;
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById('container').appendChild(renderer.domElement);
      
      // Create controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.5;
      controls.minDistance = 150;
      controls.maxDistance = 400;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;
      
      // Create Earth
      createEarth();
      
      // Create atmosphere
      createAtmosphere();
      
      // Load country borders
      loadCountryBorders();
      
      // Create container for labels
      labelContainer = document.createElement('div');
      labelContainer.style.position = 'absolute';
      labelContainer.style.top = '0';
      labelContainer.style.left = '0';
      labelContainer.style.width = '100%';
      labelContainer.style.height = '100%';
      labelContainer.style.pointerEvents = 'none';
      document.getElementById('container').appendChild(labelContainer);
      
      // Create city labels
      createCityLabels();
      
      // Set up event listeners
      setupEventListeners();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }
    
    function createEarth() {
      // Earth geometry
      const earthGeometry = new THREE.SphereGeometry(100, 64, 64);
      
      // Load Earth textures
      const textureLoader = new THREE.TextureLoader();
      
      const earthTexture = textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_8k.jpg');
      const bumpMap = textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/elev_bump_8k.jpg');
      const specularMap = textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/water_8k.png');
      
      // Earth material
      const earthMaterial = new THREE.MeshPhongMaterial({
        map: earthTexture,
        bumpMap: bumpMap,
        bumpScale: 0.5,
        specularMap: specularMap,
        specular: new THREE.Color('grey'),
        shininess: 5
      });
      
      // Create Earth mesh
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x333333);
      scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
    }
    
    function createAtmosphere() {
      // Atmosphere geometry
      const atmosphereGeometry = new THREE.SphereGeometry(102, 64, 64);
      
      // Atmosphere material
      const atmosphereMaterial = new THREE.MeshPhongMaterial({
        color: 0x4ca6ff,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide
      });
      
      // Create atmosphere mesh
      atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
      scene.add(atmosphere);
    }
    
    function loadCountryBorders() {
      fetch('https://raw.githubusercontent.com/nvkelso/natural-earth-vector/master/geojson/ne_110m_admin_0_countries.geojson')
        .then(response => response.json())
        .then(data => {
          createBordersMesh(data);
        })
        .catch(error => {
          console.error('Error loading country borders:', error);
        });
    }
    
    function createBordersMesh(geoJson) {
      if (bordersMesh) {
        scene.remove(bordersMesh);
      }
      
      if (!showBorders) return;
      
      // Create material for borders
      const bordersMaterial = new THREE.LineBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.5,
        linewidth: 1
      });
      
      // Create geometry for borders
      const bordersGeometry = new THREE.BufferGeometry();
      const vertices = [];
      
      // Process GeoJSON features
      geoJson.features.forEach(feature => {
        if (feature.geometry.type === 'Polygon') {
          processBordersPolygon(feature.geometry.coordinates, vertices);
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach(polygon => {
            processBordersPolygon(polygon, vertices);
          });
        }
      });
      
      // Set vertices
      bordersGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      
      // Create borders mesh
      bordersMesh = new THREE.LineSegments(bordersGeometry, bordersMaterial);
      scene.add(bordersMesh);
    }
    
    function processBordersPolygon(polygon, vertices) {
      polygon.forEach(ring => {
        for (let i = 0; i < ring.length - 1; i++) {
          const point1 = latLngToVector3(ring[i][1], ring[i][0], 101);
          const point2 = latLngToVector3(ring[i + 1][1], ring[i + 1][0], 101);
          
          vertices.push(point1.x, point1.y, point1.z);
          vertices.push(point2.x, point2.y, point2.z);
        }
      });
    }
    
    function createCityLabels() {
      // Clear existing labels
      while (labelContainer.firstChild) {
        labelContainer.removeChild(labelContainer.firstChild);
      }
      cityLabels = [];
      
      // Create new labels
      cities.forEach(city => {
        // Create label element
        const label = document.createElement('div');
        label.className = `city-label tier-${city.tier}`;
        label.textContent = city.name;
        label.style.display = 'none'; // Hide initially
        labelContainer.appendChild(label);
        
        // Store label and city info
        cityLabels.push({
          city: city,
          element: label,
          position: latLngToVector3(city.lat, city.lng, 100)
        });
      });
    }
    
    function updateCityLabels() {
      if (!showLabels) {
        cityLabels.forEach(label => {
          label.element.style.display = 'none';
        });
        visibleLabelCount = 0;
        return;
      }
      
      // Calculate zoom factor (0-1) based on camera distance
      const cameraDistance = camera.position.length();
      const zoomFactor = 1 - Math.min(1, Math.max(0, 
        (cameraDistance - controls.minDistance) / (controls.maxDistance - controls.minDistance)
      ));
      
      // Track visible labels for performance stats
      visibleLabelCount = 0;
      
      // Track occupied positions to prevent overlaps
      const occupiedPositions = [];
      
      // Process labels in order of importance (tier)
      [...cityLabels]
        .sort((a, b) => a.city.tier - b.city.tier)
        .forEach(item => {
          // Determine if label should be visible based on zoom level
          const shouldShow = (
            item.city.tier === 1 || // Tier 1 always visible
            (item.city.tier === 2 && zoomFactor > 0.4) || // Tier 2 visible at medium zoom
            (item.city.tier === 3 && zoomFactor > 0.65) || // Tier 3 visible at close zoom
            (item.city.tier === 4 && zoomFactor > 0.85) // Tier 4 visible at very close zoom
          );
          
          if (!shouldShow) {
            item.element.style.display = 'none';
            return;
          }
          
          // Get position in world space
          const worldPosition = item.position.clone().applyMatrix4(earth.matrixWorld);
          
          // Project to screen space
          const vector = worldPosition.clone().project(camera);
          
          // Convert to screen coordinates
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
          
          // Check if point is behind the globe
          if (vector.z > 0.1) {
            item.element.style.display = 'none';
            return;
          }
          
          // Apply adaptive sizing based on zoom
          const baseFontSize = 10 + (4 - item.city.tier) * 0.8;
          const fontSize = Math.max(9, Math.min(14, baseFontSize * (1 + zoomFactor * 0.5)));
          item.element.style.fontSize = `${fontSize}px`;
          
          // Calculate label dimensions
          const labelWidth = item.city.name.length * fontSize * 0.6;
          const labelHeight = fontSize * 2;
          
          // Check for overlaps with existing labels
          let finalX = x;
          let finalY = y;
          let hasOverlap = false;
          
          for (const occupied of occupiedPositions) {
            if (Math.abs(finalX - occupied.x) < (labelWidth + occupied.width) / 2 &&
                Math.abs(finalY - occupied.y) < (labelHeight + occupied.height) / 2) {
              hasOverlap = true;
              break;
            }
          }
          
          // If overlap, adjust position
          if (hasOverlap) {
            // Move label away from center of screen
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const dirX = x - centerX;
            const dirY = y - centerY;
            const length = Math.sqrt(dirX * dirX + dirY * dirY);
            
            if (length > 0) {
              const normX = dirX / length;
              const normY = dirY / length;
              finalX = x + normX * labelWidth;
              finalY = y + normY * labelHeight;
            }
          }
          
          // Position the label
          item.element.style.left = finalX + 'px';
          item.element.style.top = finalY + 'px';
          
          // Calculate fade based on distance from center
          const centerX = window.innerWidth / 2;
          const centerY = window.innerHeight / 2;
          const distX = finalX - centerX;
          const distY = finalY - centerY;
          const distance = Math.sqrt(distX * distX + distY * distY);
          const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);
          const normalizedDist = Math.min(1, distance / (maxDist * 0.8));
          
          // Apply fade
          const opacity = 1 - Math.pow(normalizedDist, 2);
          item.element.style.opacity = opacity;
          
          // Show the label
          item.element.style.display = 'block';
          
          // Add position to occupied list
          occupiedPositions.push({
            x: finalX,
            y: finalY,
            width: labelWidth,
            height: labelHeight
          });
          
          // Increment visible count
          visibleLabelCount++;
        });
    }
    
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      
      return new THREE.Vector3(x, y, z);
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function animate(time) {
      requestAnimationFrame(animate);
      
      // Calculate FPS
      frameCount++;
      if (time - lastFrameTime > 1000) {
        fps = Math.round(frameCount * 1000 / (time - lastFrameTime));
        frameCount = 0;
        lastFrameTime = time;
        
        // Update stats display once per second
        document.getElementById('performance-stats').textContent = 
          `FPS: ${fps} | Labels: ${visibleLabelCount}`;
      }
      
      // Update controls
      controls.update();
      
      // Rotate Earth if enabled
      if (isRotating) {
        earth.rotation.y += 0.001;
        atmosphere.rotation.y += 0.001;
        if (bordersMesh) bordersMesh.rotation.y += 0.001;
      }
      
      // Update city labels at a reduced frequency for better performance
      if (!lastLabelUpdateTime || time - lastLabelUpdateTime > 100) {
        updateCityLabels();
        lastLabelUpdateTime = time;
      }
      
      // Smooth zoom interpolation
      if (Math.abs(zoomLevel - targetZoomLevel) > 0.01) {
        zoomLevel += (targetZoomLevel - zoomLevel) * 0.1;
        
        // Apply zoom level
        const direction = camera.position.clone().normalize();
        const distance = controls.minDistance + (1 - zoomLevel) * (controls.maxDistance - controls.minDistance);
        camera.position.copy(direction.multiplyScalar(distance));
      }
      
      // Render
      renderer.render(scene, camera);
    }
    
    function setupEventListeners() {
      // Rotation toggle
      document.getElementById('toggle-rotation').addEventListener('click', function() {
        isRotating = !isRotating;
        this.textContent = isRotating ? 'Pause Rotation' : 'Resume Rotation';
        controls.autoRotate = isRotating;
      });
      
      // Borders toggle
      document.getElementById('toggle-borders').addEventListener('click', function() {
        showBorders = !showBorders;
        this.textContent = showBorders ? 'Hide Borders' : 'Show Borders';
        loadCountryBorders();
      });
      
      // Labels toggle
      document.getElementById('toggle-labels').addEventListener('click', function() {
        showLabels = !showLabels;
        this.textContent = showLabels ? 'Hide Labels' : 'Show Labels';
        updateCityLabels();
      });
      
      // Zoom in
      document.getElementById('zoom-in').addEventListener('click', function() {
        zoomIn();
      });
      
      // Zoom out
      document.getElementById('zoom-out').addEventListener('click', function() {
        zoomOut();
      });
    }
    
    function zoomIn() {
      // Update target zoom level
      targetZoomLevel = Math.min(1, targetZoomLevel + 0.2);
      
      // Get current camera position
      const currentDist = camera.position.length();
      const newDist = Math.max(currentDist * 0.8, controls.minDistance);
      
      // Animate zoom with easing
      const startPos = camera.position.clone();
      const endPos = camera.position.clone().normalize().multiplyScalar(newDist);
      const startTime = Date.now();
      const duration = 800; // 800ms for smooth transition
      
      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Cubic ease-out for smooth deceleration
        const eased = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        camera.position.lerpVectors(startPos, endPos, eased);
        controls.update();
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        }
      }
      
      animateZoom();
    }
    
    function zoomOut() {
      // Update target zoom level
      targetZoomLevel = Math.max(0, targetZoomLevel - 0.2);
      
      // Get current camera position
      const currentDist = camera.position.length();
      const newDist = Math.min(currentDist * 1.2, controls.maxDistance);
      
      // Animate zoom with easing
      const startPos = camera.position.clone();
      const endPos = camera.position.clone().normalize().multiplyScalar(newDist);
      const startTime = Date.now();
      const duration = 800; // 800ms for smooth transition
      
      function animateZoom() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Cubic ease-out for smooth deceleration
        const eased = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        camera.position.lerpVectors(startPos, endPos, eased);
        controls.update();
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateZoom);
        }
      }
      
      animateZoom();
    }
  </script>
</body>
</html>