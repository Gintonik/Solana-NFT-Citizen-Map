<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced 3D Globe with City Labels</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #000;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }
    
    #container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .city-label {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      border: 1px solid rgba(255, 255, 255, 0.5);
      white-space: nowrap;
      z-index: 100;
      transition: opacity 0.3s ease, font-size 0.3s ease;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
    }
    
    .city-label.tier-1 {
      font-size: 14px;
      font-weight: bold;
      background-color: rgba(0, 0, 0, 0.8);
      border-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }
    
    .city-label.tier-2 {
      font-size: 13px;
      font-weight: bold;
      background-color: rgba(0, 0, 0, 0.75);
    }
    
    .city-label.tier-3 {
      font-size: 12px;
      background-color: rgba(0, 0, 0, 0.7);
    }
    
    .city-label.tier-4 {
      font-size: 11px;
      background-color: rgba(0, 0, 0, 0.65);
    }
    
    .controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 8px;
      z-index: 10;
    }
    
    .controls button {
      background: #333;
      color: white;
      border: none;
      padding: 8px 12px;
      margin: 4px;
      border-radius: 4px;
      cursor: pointer;
    }
    
    .controls button:hover {
      background: #444;
    }
    
    #stats {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px;
      color: #0f0;
      border-radius: 4px;
      font-family: monospace;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="stats">FPS: 0 | Labels: 0</div>
    <div class="controls">
      <button id="zoomIn">Zoom In</button>
      <button id="zoomOut">Zoom Out</button>
      <button id="toggleRotation">Pause Rotation</button>
      <button id="toggleLabels">Hide Labels</button>
    </div>
  </div>
  
  <script>
    // App state
    let isRotating = true;
    let showLabels = true;
    let targetZoomLevel = 0.5; // Initial zoom level (0-1)
    let currentZoomLevel = 0.5;
    let lastFrameTime = 0;
    let frameCount = 0;
    let fps = 0;
    let visibleLabelCount = 0;
    
    // Three.js objects
    let scene, camera, renderer, controls;
    let earth, atmosphere;
    
    // City data with tiers for zoom-based visibility
    const cities = [
      // Tier 1 - Major cities - Always visible
      { name: "New York", lat: 40.7128, lng: -74.0060, tier: 1 },
      { name: "Tokyo", lat: 35.6762, lng: 139.6503, tier: 1 },
      { name: "London", lat: 51.5074, lng: -0.1278, tier: 1 },
      { name: "Beijing", lat: 39.9042, lng: 116.4074, tier: 1 },
      { name: "Shanghai", lat: 31.2304, lng: 121.4737, tier: 1 },
      { name: "Delhi", lat: 28.7041, lng: 77.1025, tier: 1 },
      { name: "Mexico City", lat: 19.4326, lng: -99.1332, tier: 1 },
      { name: "SÃ£o Paulo", lat: -23.5505, lng: -46.6333, tier: 1 },
      
      // Tier 2 - Large cities - Visible at medium zoom
      { name: "Paris", lat: 48.8566, lng: 2.3522, tier: 2 },
      { name: "Los Angeles", lat: 34.0522, lng: -118.2437, tier: 2 },
      { name: "Moscow", lat: 55.7558, lng: 37.6173, tier: 2 },
      { name: "Sydney", lat: -33.8688, lng: 151.2093, tier: 2 },
      { name: "Rio de Janeiro", lat: -22.9068, lng: -43.1729, tier: 2 },
      { name: "Cairo", lat: 30.0444, lng: 31.2357, tier: 2 },
      { name: "Singapore", lat: 1.3521, lng: 103.8198, tier: 2 },
      { name: "Hong Kong", lat: 22.3193, lng: 114.1694, tier: 2 },
      { name: "Istanbul", lat: 41.0082, lng: 28.9784, tier: 2 },
      { name: "Seoul", lat: 37.5665, lng: 126.9780, tier: 2 },
      
      // Tier 3 - Medium cities - Visible at close zoom
      { name: "Madrid", lat: 40.4168, lng: -3.7038, tier: 3 },
      { name: "Rome", lat: 41.9028, lng: 12.4964, tier: 3 },
      { name: "Berlin", lat: 52.5200, lng: 13.4050, tier: 3 },
      { name: "Chicago", lat: 41.8781, lng: -87.6298, tier: 3 },
      { name: "Toronto", lat: 43.6532, lng: -79.3832, tier: 3 },
      { name: "Dubai", lat: 25.2048, lng: 55.2708, tier: 3 },
      { name: "San Francisco", lat: 37.7749, lng: -122.4194, tier: 3 },
      { name: "Bangkok", lat: 13.7563, lng: 100.5018, tier: 3 },
      { name: "Mumbai", lat: 19.0760, lng: 72.8777, tier: 3 },
      { name: "Jakarta", lat: -6.2088, lng: 106.8456, tier: 3 },
      
      // Tier 4 - Small cities - Visible only at very close zoom
      { name: "Amsterdam", lat: 52.3676, lng: 4.9041, tier: 4 },
      { name: "Las Vegas", lat: 36.1699, lng: -115.1398, tier: 4 },
      { name: "Miami", lat: 25.7617, lng: -80.1918, tier: 4 },
      { name: "Lisbon", lat: 38.7223, lng: -9.1393, tier: 4 },
      { name: "Athens", lat: 37.9838, lng: 23.7275, tier: 4 },
      { name: "Prague", lat: 50.0755, lng: 14.4378, tier: 4 },
      { name: "Vancouver", lat: 49.2827, lng: -123.1207, tier: 4 },
      { name: "Seattle", lat: 47.6062, lng: -122.3321, tier: 4 },
      { name: "Dublin", lat: 53.3498, lng: -6.2603, tier: 4 },
      { name: "Vienna", lat: 48.2082, lng: 16.3738, tier: 4 }
    ];
    
    // City label elements
    const cityLabels = [];
    
    // Initialize
    function init() {
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 250;
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);
      
      // Create controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.5;
      controls.minDistance = 150;
      controls.maxDistance = 400;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.15; // Slow rotation speed
      
      // Create Earth
      createEarth();
      
      // Create atmosphere
      createAtmosphere();
      
      // Create city labels
      createCityLabels();
      
      // Set up event listeners
      setupEventListeners();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
    }
    
    function createEarth() {
      // Create Earth geometry
      const earthGeometry = new THREE.SphereGeometry(100, 64, 64);
      
      // Create Earth material with texture
      const textureLoader = new THREE.TextureLoader();
      const earthTexture = textureLoader.load('https://images.unsplash.com/photo-1451187580459-43490279c0fa?q=80&w=2072&auto=format&fit=crop');
      
      // Create Earth material
      const earthMaterial = new THREE.MeshPhongMaterial({
        map: earthTexture,
        specular: new THREE.Color('grey'),
        shininess: 5
      });
      
      // Create Earth mesh
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);
      
      // Add ambient light
      const ambientLight = new THREE.AmbientLight(0x333333);
      scene.add(ambientLight);
      
      // Add directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
    }
    
    function createAtmosphere() {
      // Create atmosphere geometry
      const atmosphereGeometry = new THREE.SphereGeometry(102, 64, 64);
      
      // Create atmosphere material
      const atmosphereMaterial = new THREE.MeshPhongMaterial({
        color: 0x4ca6ff,
        transparent: true,
        opacity: 0.2,
        side: THREE.BackSide
      });
      
      // Create atmosphere mesh
      atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
      scene.add(atmosphere);
    }
    
    function createCityLabels() {
      // Create container for labels
      const labelContainer = document.getElementById('container');
      
      // Create label elements for each city
      cities.forEach(city => {
        const label = document.createElement('div');
        label.className = `city-label tier-${city.tier}`;
        label.textContent = city.name;
        label.style.display = 'none'; // Hidden initially
        labelContainer.appendChild(label);
        
        // Store city information
        cityLabels.push({
          element: label,
          position: latLngToVector3(city.lat, city.lng, 100),
          city: city
        });
      });
    }
    
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      
      return new THREE.Vector3(x, y, z);
    }
    
    function setupEventListeners() {
      // Zoom in button
      document.getElementById('zoomIn').addEventListener('click', () => {
        targetZoomLevel = Math.min(1, targetZoomLevel + 0.2);
      });
      
      // Zoom out button
      document.getElementById('zoomOut').addEventListener('click', () => {
        targetZoomLevel = Math.max(0, targetZoomLevel - 0.2);
      });
      
      // Toggle rotation button
      document.getElementById('toggleRotation').addEventListener('click', () => {
        isRotating = !isRotating;
        controls.autoRotate = isRotating;
        document.getElementById('toggleRotation').textContent = isRotating ? 'Pause Rotation' : 'Resume Rotation';
      });
      
      // Toggle labels button
      document.getElementById('toggleLabels').addEventListener('click', () => {
        showLabels = !showLabels;
        document.getElementById('toggleLabels').textContent = showLabels ? 'Hide Labels' : 'Show Labels';
      });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function updateCityLabels() {
      if (!showLabels) {
        // Hide all labels if labels are toggled off
        cityLabels.forEach(item => {
          item.element.style.display = 'none';
        });
        visibleLabelCount = 0;
        return;
      }
      
      // Calculate current zoom factor (0-1)
      const cameraDistance = camera.position.length();
      const zoomFactor = Math.max(0, Math.min(1, 
        (controls.maxDistance - cameraDistance) / (controls.maxDistance - controls.minDistance)
      ));
      
      // Track visible labels for performance monitoring
      visibleLabelCount = 0;
      
      // Track occupied positions to prevent overlaps
      const occupiedPositions = [];
      
      // Process labels in order of importance (tier)
      [...cityLabels]
        .sort((a, b) => a.city.tier - b.city.tier)
        .forEach(item => {
          // Determine if label should be shown based on zoom level
          const shouldShow = (
            item.city.tier === 1 || // Tier 1 - always visible
            (item.city.tier === 2 && zoomFactor > 0.3) || // Tier 2 - medium zoom
            (item.city.tier === 3 && zoomFactor > 0.6) || // Tier 3 - close zoom
            (item.city.tier === 4 && zoomFactor > 0.85)   // Tier 4 - very close zoom
          );
          
          if (!shouldShow) {
            item.element.style.display = 'none';
            return;
          }
          
          // Get position in world space
          const worldPosition = item.position.clone();
          worldPosition.applyMatrix4(earth.matrixWorld);
          
          // Project to screen space
          const vector = worldPosition.clone().project(camera);
          
          // Convert to screen coordinates
          const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
          const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
          
          // Check if city is behind the globe (not visible)
          if (vector.z > 0.1) {
            item.element.style.display = 'none';
            return;
          }
          
          // Apply adaptive sizing based on zoom and importance
          const baseFontSize = 9 + (4 - item.city.tier) * 1.2;
          const fontSize = Math.max(9, Math.min(16, baseFontSize * (1 + zoomFactor * 0.5)));
          item.element.style.fontSize = `${fontSize}px`;
          
          // Calculate label dimensions for overlap detection
          const labelWidth = item.city.name.length * fontSize * 0.6;
          const labelHeight = fontSize * 2;
          
          // Find non-overlapping position
          let finalPosition = {
            x: x,
            y: y
          };
          
          // Check for overlaps
          let hasOverlap = false;
          for (const occupied of occupiedPositions) {
            if (Math.abs(finalPosition.x - occupied.x) < (labelWidth + occupied.width) / 2 &&
                Math.abs(finalPosition.y - occupied.y) < (labelHeight + occupied.height) / 2) {
              hasOverlap = true;
              break;
            }
          }
          
          // If overlap, find better position
          if (hasOverlap) {
            // Move label away from center
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const dirX = x - centerX;
            const dirY = y - centerY;
            const length = Math.sqrt(dirX * dirX + dirY * dirY);
            
            if (length > 0) {
              // Normalize direction
              const normX = dirX / length;
              const normY = dirY / length;
              
              // Move in that direction
              finalPosition.x = x + normX * labelWidth;
              finalPosition.y = y + normY * labelHeight;
            }
          }
          
          // Position the label
          item.element.style.left = `${finalPosition.x}px`;
          item.element.style.top = `${finalPosition.y}px`;
          item.element.style.display = 'block';
          
          // Track the occupied position
          occupiedPositions.push({
            x: finalPosition.x,
            y: finalPosition.y,
            width: labelWidth,
            height: labelHeight
          });
          
          // Count visible labels
          visibleLabelCount++;
        });
        
      // Update stats
      document.getElementById('stats').textContent = `FPS: ${fps.toFixed(1)} | Labels: ${visibleLabelCount}`;
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Calculate FPS
      const now = performance.now();
      frameCount++;
      
      if (now - lastFrameTime >= 1000) {
        fps = frameCount * 1000 / (now - lastFrameTime);
        frameCount = 0;
        lastFrameTime = now;
      }
      
      // Update controls
      controls.update();
      
      // Rotate Earth if enabled
      if (isRotating) {
        earth.rotation.y += 0.0005; // Very slow rotation
        if (atmosphere) atmosphere.rotation.y += 0.0005;
      }
      
      // Smooth zoom interpolation
      if (Math.abs(currentZoomLevel - targetZoomLevel) > 0.01) {
        currentZoomLevel += (targetZoomLevel - currentZoomLevel) * 0.1;
        
        // Calculate new camera position
        const direction = camera.position.clone().normalize();
        const distance = controls.minDistance + (1 - currentZoomLevel) * (controls.maxDistance - controls.minDistance);
        camera.position.copy(direction.multiplyScalar(distance));
      }
      
      // Update city labels on every frame
      updateCityLabels();
      
      // Render scene
      renderer.render(scene, camera);
    }
    
    // Load Three.js scripts
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }
    
    // Load scripts sequentially
    Promise.all([
      loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js'),
      loadScript('https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js')
    ]).then(() => {
      init();
      animate();
    }).catch(error => {
      console.error('Failed to load Three.js:', error);
      document.getElementById('container').innerHTML = '<div style="color: white; padding: 20px;">Error loading 3D libraries. Please check your internet connection.</div>';
    });
  </script>
</body>
</html>