<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Globe with Borders</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background-color: #000;
      font-family: Arial, sans-serif;
    }
    
    #globe-container {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .city-label {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      border: 1px solid rgba(255, 255, 255, 0.5);
      white-space: nowrap;
      z-index: 100;
    }
    
    .city-label.tier-1 {
      font-size: 14px;
      font-weight: bold;
      background-color: rgba(0, 0, 0, 0.8);
      border-color: rgba(255, 255, 255, 0.7);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
    }
    
    .controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 100;
    }
    
    .button-row {
      display: flex;
      gap: 5px;
    }
    
    button {
      background-color: rgba(30, 30, 30, 0.7);
      color: white;
      border: 1px solid #444;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: rgba(60, 60, 60, 0.7);
    }
    
    #loading {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      z-index: 1000;
    }
    
    .spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <p>Loading globe...</p>
  </div>

  <div id="globe-container"></div>
  
  <div class="controls">
    <div class="button-row">
      <button id="zoomIn">Zoom In</button>
      <button id="zoomOut">Zoom Out</button>
    </div>
    <div class="button-row">
      <button id="toggleRotation">Pause Rotation</button>
      <button id="toggleLabels">Hide Labels</button>
    </div>
    <div class="button-row">
      <button id="resetView">Reset View</button>
    </div>
  </div>

  <script>
    // State variables
    let scene, camera, renderer, controls;
    let earth, atmosphere;
    let isRotating = true;
    let showLabels = true;
    let cityLabels = [];
    
    // Major cities with tiers
    const cities = [
      { name: "New York", lat: 40.7128, lng: -74.0060, tier: 1 },
      { name: "Tokyo", lat: 35.6762, lng: 139.6503, tier: 1 },
      { name: "London", lat: 51.5074, lng: -0.1278, tier: 1 },
      { name: "Beijing", lat: 39.9042, lng: 116.4074, tier: 1 },
      
      { name: "Paris", lat: 48.8566, lng: 2.3522, tier: 2 },
      { name: "Moscow", lat: 55.7558, lng: 37.6173, tier: 2 },
      { name: "Sydney", lat: -33.8688, lng: 151.2093, tier: 2 },
      { name: "Rio", lat: -22.9068, lng: -43.1729, tier: 2 }
    ];

    // Wait for resources to load
    window.addEventListener('load', () => {
      // Initialize globe when everything is loaded
      initGlobe();
    });

    function initGlobe() {
      // Create scene
      scene = new THREE.Scene();
      
      // Create camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 250;
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('globe-container').appendChild(renderer.domElement);
      
      // Create orbit controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.rotateSpeed = 0.5;
      controls.minDistance = 150;
      controls.maxDistance = 400;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.2;
      
      // Add lights
      const ambientLight = new THREE.AmbientLight(0x333333);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(5, 3, 5);
      scene.add(directionalLight);
      
      // Create Earth
      createEarth();
      
      // Create atmosphere
      createAtmosphere();
      
      // Create city labels
      createCityLabels();
      
      // Setup event listeners
      setupEventListeners();
      
      // Start animation loop
      animate();
      
      // Handle window resize
      window.addEventListener('resize', onWindowResize);
      
      // Hide loading screen after a short delay
      setTimeout(() => {
        document.getElementById('loading').style.display = 'none';
      }, 1000);
    }
    
    function createEarth() {
      // Create Earth geometry
      const earthGeometry = new THREE.SphereGeometry(100, 64, 32);
      
      // Create Earth material
      const earthMaterial = new THREE.MeshPhongMaterial({
        color: 0x2233aa,
        specular: 0x333333,
        shininess: 5,
        emissive: 0x112244
      });
      
      // Create Earth mesh
      earth = new THREE.Mesh(earthGeometry, earthMaterial);
      scene.add(earth);
      
      // Add wireframe for country borders
      const wireframe = new THREE.WireframeGeometry(earthGeometry);
      const borders = new THREE.LineSegments(wireframe);
      borders.material.color.set(0xffffff);
      borders.material.transparent = true;
      borders.material.opacity = 0.2;
      earth.add(borders);
    }
    
    function createAtmosphere() {
      // Create atmosphere geometry
      const atmosphereGeometry = new THREE.SphereGeometry(102, 64, 32);
      
      // Create atmosphere material
      const atmosphereMaterial = new THREE.MeshPhongMaterial({
        color: 0x4ca6ff,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      });
      
      // Create atmosphere mesh
      atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
      scene.add(atmosphere);
    }
    
    function createCityLabels() {
      const container = document.getElementById('globe-container');
      
      cities.forEach(city => {
        // Create label element
        const label = document.createElement('div');
        label.className = `city-label${city.tier === 1 ? ' tier-1' : ''}`;
        label.textContent = city.name;
        label.style.display = 'none'; // Hidden initially
        container.appendChild(label);
        
        // Store city data
        cityLabels.push({
          element: label,
          position: latLngToVector3(city.lat, city.lng, 100),
          city: city
        });
      });
    }
    
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      
      return new THREE.Vector3(x, y, z);
    }
    
    function setupEventListeners() {
      // Zoom in button
      document.getElementById('zoomIn').addEventListener('click', () => {
        const newPos = camera.position.clone().normalize().multiplyScalar(Math.max(controls.minDistance, camera.position.length() - 50));
        camera.position.copy(newPos);
      });
      
      // Zoom out button
      document.getElementById('zoomOut').addEventListener('click', () => {
        const newPos = camera.position.clone().normalize().multiplyScalar(Math.min(controls.maxDistance, camera.position.length() + 50));
        camera.position.copy(newPos);
      });
      
      // Toggle rotation button
      document.getElementById('toggleRotation').addEventListener('click', () => {
        isRotating = !isRotating;
        controls.autoRotate = isRotating;
        document.getElementById('toggleRotation').textContent = isRotating ? 'Pause Rotation' : 'Resume Rotation';
      });
      
      // Toggle labels button
      document.getElementById('toggleLabels').addEventListener('click', () => {
        showLabels = !showLabels;
        document.getElementById('toggleLabels').textContent = showLabels ? 'Hide Labels' : 'Show Labels';
      });
      
      // Reset view button
      document.getElementById('resetView').addEventListener('click', () => {
        camera.position.set(0, 0, 250);
        camera.lookAt(0, 0, 0);
      });
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function updateCityLabels() {
      if (!showLabels) {
        cityLabels.forEach(item => {
          item.element.style.display = 'none';
        });
        return;
      }
      
      cityLabels.forEach(item => {
        // Get world position
        const worldPos = item.position.clone();
        worldPos.applyMatrix4(earth.matrixWorld);
        
        // Check if city is on the back side of the globe
        const normalized = worldPos.clone().normalize();
        const cameraDirection = camera.position.clone().normalize();
        const dotProduct = normalized.dot(cameraDirection);
        
        if (dotProduct < -0.1) {
          item.element.style.display = 'none';
          return;
        }
        
        // Project to screen space
        const screenPos = worldPos.clone().project(camera);
        
        // Convert to screen coordinates
        const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
        const y = (-screenPos.y * 0.5 + 0.5) * window.innerHeight;
        
        // Update label position
        item.element.style.left = `${x}px`;
        item.element.style.top = `${y}px`;
        item.element.style.display = 'block';
      });
    }
    
    function animate() {
      requestAnimationFrame(animate);
      
      // Update controls
      controls.update();
      
      // Rotate Earth if enabled
      if (isRotating && !controls.enableDamping) {
        earth.rotation.y += 0.001;
        if (atmosphere) atmosphere.rotation.y += 0.001;
      }
      
      // Update city labels
      updateCityLabels();
      
      // Render
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>